# 4.7 pbgo : Protobuf-based framework

Pbgo là một mini-framework được thiết kế trong chương này. Chúng dựa trên cú pháp mở rộng của Protobuf và tự động sinh ra mã nguồn `RPC` và `REST` thông qua các plugins. Trong phần này của chương chúng ta sẽ hiện thực việc tùy biến mã nguồn của Protobuf code generation plugin và sinh ra mã nguồn cho phần `RPC`.

## 4.7.1 Cú pháp mở rộng của Protobuf

Những cú pháp mở rộng của Protobuf hiện tại được dùng trong nhiều dự án opensource liên quan đến Protobuf. Ở phần trước (phần 4.6) chúng ta đã đề cập về `validator`, nó được verified bằng việc thêm vào một thông tin mở rộng vào các thành viên của đối tượng trong file proto. Trong dự án `grpc-gateway`, việc hỗ trợ REST interface đạt được bằng cách thêm vào những rules có chứa thông tin về HTTP cho mỗi method của service. Pbgo cũng thêm thông tin vào REST interface thông qua cú pháp mở rộng của Protobuf.

Phần cú pháp mở rộng của pbgo là `github.com/chai2010/pbgo/pbgo.proto` được định nghĩa như sau

```proto
syntax = "proto3";
package pbgo;

option go_package = "github.com/chai2010/pbgo;pbgo";

import "google/protobuf/descriptor.proto";

extend google.protobuf.MethodOptions {
    HttpRule rest_api = 20180715;
}

message HttpRule {
    string get = 1;
    string put = 2;
    string post = 3;
    string delete = 4;
    string patch = 5;
}
```

File `pbgo.proto` là một phần của framework `pbgo` và cần được imported bởi những file proto khác. Bản thân Protobuf có một hệ thống các package, và đường dẫn đến package này là `pbgo`. Ngôn ngữ Go cũng có một tập hợp một hệ thống các gói, chúng ta cần định nghĩa sự mapping mối quan hệ giữa Protobuf và Go thông qua cú pháp mở rộng của `go_package`. Sau khi định nghĩa mapping đó, những Protobuf file khác mà được import vào gói `pbgo.ptoto` sẽ sinh ra đường dẫn tới `Go language package` của `pbgo.proto` mapping khi ngôn ngữ Go sinh ra chúng.


Có năm kiểu mở rộng của cú pháp Protobuf, những thông tin về  kiểu mở rộng đó về files, hoặc messages, phần mở rộng của message members, thông tin mở rộng của service, và service methods. Trước khi sử dụng phần mở rộng, đầu tiên chúng ta cần định nghĩa kiểu của phần mở rộng và những thành phần mà nó sử dụng cho phần mở rộng bằng từ khóa extend. Một thành phần extented có thể hoặc là một kiểu cơ bản, hoặc một kiểu cấu trúc. Pbgo chỉ định nghĩa phần mở rộng của phương thức service, chỉ định nghĩa một extension member có tên `rest_api`, kiểu của cấu trúc `HttpRule`.

Một khi extension đã được định nghĩa, chúng ta có thể sử dụng pbgo extension từ những file Protobuf khác, ta tạo một file hello.proto như sau:

```proto
syntax = "proto3";
package hello_pb;

import "github.com/chai2010/pbgo/pbgo.proto";

message String {
    string value = 1;
}

service HelloService {
    rpc Hello (String) returns (String) {
        option (pbgo.rest_api) = {
            get: "/hello/:value"
        };
    }
}
```



Đầu tiên, `github.com/chai2010/pbgo/pbgo.proto` là phần giới thiệu extension được định nghĩa bởi việc import file, và sau đó chúng ta sẽ dùng extension đã được định nghĩa bởi pbgo trong phương thức Hello của HelloService. Thông tin của phần mở rộng của phương thức Hello sẽ chỉ ra phương thức tương ứng với REST interface, và chỉ một ghi phương thức GET tương ứng với đường dẫn "/hello/:value". Cú pháp của gói routing httprouter được dùng trong đường dẫn phương thức REST. ":value"  chỉ ra rằng một trường của đường dẫn sẽ tương ứng với thành phần với cùng tên trong parameter.


## 4.7.2 Đọc thông tin extended của plugin

Trong phần trước của chương này, chúng tôi đã giới thiệu ngắn gọn làm thế nào mà plugin Protobuf làm việc và chỉ ra cách sinh ra mã nguồn cho RPC. Plugin đó là interface `generator.Plugin`.

```go
type Plugin interface {
    // Name identifies the plugin.
    Name() string
    // Init is called once after data structures are built but before
    // code generation begins.
    Init(g *Generator)
    // Generate produces the code generated by the plugin for this file,
    // except for the imports, by calling the generator's methods P, In,
    // and Out.
    Generate(file *FileDescriptor)
    // GenerateImports produces the import declarations for this file.
    // It is called after Generate.
    GenerateImports(file *FileDescriptor)
}
```

Chúng ta cần sinh ra mã nguồn thích hợp trong hai hàm `Generate` và `GenerateImports` một cách tương ứng. Toàn bộ thông tin của file Protobuf được miêu tả ở kiểu tham số `*generator.FileDescriptor`, do đó chúng ta cần mở rộng việc định nghĩa metadata trước các tham số hàm.

Đối tượng plugin trong framework `pbgo` là `pbgoPlugin`. Trong hàm `Generate`, đầu tiên chúng ta cần duyệt lần lượt qua tất cả các `services` được định nghĩa trong file Protobuf, và sau đó duyệt mỗi phương thức trong mỗi `service`. Sau khi lấy được cấu trúc của phương thức, trích dẫn phần thông tin còn lại của extension thông qua phương thức `getServiceMethodOption` đã được custom.

```go
func (p *pbgoPlugin) Generate(file *generator.FileDescriptor) {
    for _, svc := range file.Service {
        for _, m := range svc.Method {
            httpRule := p.getServiceMethodOption(m)
            ...
        }
    }
}
```


Trước khi chúng ta nói về phương thức `getServiceMethodOption`, hãy điểm lại định nghĩa phần extension của phương thức.

```go
extend google.protobuf.MethodOptions {
    HttpRule rest_api = 20180715;
}
```



`Pbgo` định nghĩa một extension của phương thức service có tên `rest_api`. Kết quả của mã nguồn Go sẽ bao gồm một biến toàn cục là `pbgo.E_RestApi`, thông qua đó có thể thu được thông tin mở rộng do người dùng định nghĩa.

Bên dưới là phần hiện thực phương thức `getServiceMethodOption`

```go
func (p *pbgoPlugin) getServiceMethodOption(
    m *descriptor.MethodDescriptorProto,
) *pbgo.HttpRule {
    if m.Options != nil && proto.HasExtension(m.Options, pbgo.E_RestApi) {
        ext, _ := proto.GetExtension(m.Options, pbgo.E_RestApi)
        if ext != nil {
            if x, _ := ext.(*pbgo.HttpRule); x != nil {
                return x
            }
        }
    }
    return nil
}
```


Trước tiên, xác định khi nào mỗi phương thức được định nghĩa một extension bằng việc dùng hàm `proto.HasExtension`, và sau đó lấy thông tin của user-defined thông qua hàm `proto.GetExtension`, sau khi lấy được phần thông tin extension đó, chúng sẽ biến đổi extension thành kiểu `pbgo.HttpRule`.

Với thông tin về extension trên, chúng ta có thể sinh ra mã nguồn REST bằng việc tham khảo đến cách mà mã nguồn RPC được sinh ra ở phần hai.

## 4.7.3 Sinh ra REST code

Framework `pbgo` cũng hỗ trợ một số plugin cho việc sinh ra REST code. Tuy nhiên, mục tiêu của chúng ta là học được quy trình thiết kế framework `pbgo`, do đó đầu tiên chúng ta phải viết REST code ứng với phương thức Hello, và sau đó phần plugin tự động được sinh ra dựa trên một khuôn mẫu code đã được dựng sẵn.

HelloService chỉ có một phương thức là Hello, phương thức Hello chỉ định nghĩa một REST interface.

```proto
message String {
    string value = 1;
}

service HelloService {
    rpc Hello (String) returns (String) {
        option (pbgo.rest_api) = {
            get: "/hello/:value"
        };
    }
}
```


Để final user dễ dàng sử dụng, chúng ta cần xây dựng một route đến `HelloService`. Do đó, chúng ta sẽ có một hàm giống như `HelloServiceHandler` để sinh ra mã nguồn route handler dựa trên interface của service `HelloServiceInterface`.

```go
type HelloServiceInterface interface {
    Hello(in *String, out *String) error
}

func HelloServiceHandler(svc HelloServiceInterface) http.Handler {
    var router = httprouter.New()
    _handle_HelloService_Hello_get(router, svc)
    return router
}
```



Mã nguồn chọn một opensource `httprouter routing engine` nổi tiếng. Hàm `_handle_HelloService_Hello_get` được dùng để register hàm `Hello` cho `route handler`.

```go
func _handle_HelloService_Hello_get(
    router *httprouter.Router, svc HelloServiceInterface,
) {
    router.Handle("GET", "/hello/:value",
        func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
            var protoReq, protoReply String

            err := pbgo.PopulateFieldFromPath(&protoReq, fieldPath, ps.ByName("value"))
            if err != nil {
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
            }

            if err := svc.Hello(&protoReq, &protoReply); err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }

            if err := json.NewEncoder(w).Encode(&protoReply); err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }
        },
    )
}
```

Đầu tiên, register routing function thông qua hàm `router.Handle`. Bên trong hàm routing, ta thấy xuất hiện `ps.ByName("value")` sẽ load những giá trị parameter từ URL, và sau đó thiết lập thành phần ứng với giá trị của parameter thông qua hàm `pbgo.PopulateFieldFromPath`. Sau khi tham số đầu vào đã sẵn sàng, bạn có thể gọi phương thức Hello của service `HelloService`, và cuối cùng trả về kết quả bởi hàm `Hello` với json code.

Sau khi thiết lập cấu trúc mã nguồn, bạn có thể xây dựng một template cho việc sinh ra mã nguồn plugin cơ bản. Toàn bộ plugin code và template nằm trong file `protoc-gen-pbgo/pbgo.go`.

## 4.7.4 Bắt đầu REST Service

Mặc dù quy trình để xây dựng một `pbgo` framework từ ban đầu là cồng kềnh, dùng `pbgo` để xây dựng một REST service cực kì đơn giản. Đầu tiên, xây dựng đối tượng service thỏa mãn interface `HelloServiceInterface`.

```go
import (
    "github.com/chai2010/pbgo/examples/hello.pb"
)

type HelloService struct{}

func (p *HelloService) Hello(request *hello_pb.String, reply *hello_pb.String) error {
    reply.Value = "hello:" + request.GetValue()
    return nil
}
```


Như đã đề cập mã nguồn RPC, đơn giản trả về kết quả của phương thức Hello. Sau đó chúng ta gọi hàm `HelloServiceHandler` tương ứng với service để sinh ra route processor và start service.

```go
func main() {
    router := hello_pb.HelloServiceHandler(new(HelloService))
    log.Fatal(http.ListenAndServe(":8080", router))
}
```

Sau đó test REST service bằng lệnh sau

```sh
curl localhost:8080/hello/vgo
```

Như vậy một framework `pbgo` đơn giản được hoàn thành.